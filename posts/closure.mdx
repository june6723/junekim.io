---
status: draft
type: Shorts
title: 클로저
date: 2025-01-01
description: 클로저
---

클로저는 함수와 함수가 선언된 렉시컬 환경의 조합입니다. 클로저는 함수가 자신이 선언된 렉시컬 환경에 있는 변수에 접근할 수 있도록 합니다.

## 실행 컨텍스트와 렉시컬 환경

자바스크립트 엔진은 코드를 실행할 때 '평가'와 '실행' 두 단계로 나누어 처리합니다:

1. **평가 단계**

   - 전역 실행 컨텍스트(Execution Context) 생성
   - 변수 선언 처리
   - 실행 컨텍스트 스택에 추가

2. **실행 단계**
   - 함수 호출 시 새로운 실행 컨텍스트 생성
   - 함수의 지역 변수 선언
   - 실행 컨텍스트 스택에 추가

### 렉시컬 환경(Lexical Environment)

렉시컬 환경은 식별자와 값의 매핑을 관리하며, 두 가지 주요 컴포넌트를 가집니다:

- 환경 레코드(Environment Record): 스코프 내의 변수들을 저장
- 외부 렉시컬 환경에 대한 참조: 스코프 체인을 구현

### 클로저와 메모리

중요한 점은 실행 컨텍스트와 렉시컬 환경의 생명주기가 다르다는 것입니다:

- 실행 컨텍스트: 함수 실행이 완료되면 스택에서 제거됨
- 렉시컬 환경: 내부 함수가 외부 함수의 변수를 참조하는 한 메모리에 유지됨

이러한 특성으로 인해 클로저가 가능해지며, 이는 함수가 자신이 선언된 환경의 변수들에 지속적으로 접근할 수 있게 해줍니다.

### 클로저 예시

다음 예시를 통해 실행 컨텍스트와 렉시컬 환경의 생명주기 차이를 확인해보겠습니다:

```js
function outer() {
  let count = 0; // outer 함수의 지역 변수
  function inner() {
    count++; // outer의 변수를 참조
    console.log(count);
  }
  return inner; // inner 함수를 반환
}
const increment = outer(); // outer 실행 컨텍스트는 여기서 종료
increment(); // 1
increment(); // 2
increment(); // 3
```

이 예시에서:

1. `outer()` 함수가 실행되면서 `count` 변수와 `inner` 함수가 생성됩니다.
2. `outer()` 함수의 실행이 끝나면 실행 컨텍스트는 스택에서 제거됩니다.
3. 하지만 `inner` 함수가 `count` 변수를 참조하고 있기 때문에, `outer`의 렉시컬 환경은 메모리에 계속 유지됩니다.
4. 이후 `increment()`를 호출할 때마다 `count` 값이 증가하는 것을 확인할 수 있습니다.

이처럼 클로저를 통해 함수의 실행이 종료된 후에도 해당 함수의 렉시컬 환경에 접근할 수 있습니다.
